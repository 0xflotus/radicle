{:module 'prelude/test
 :doc "Provides eval that adds a `:test` macro."
 :exports '[run run-all assert-equal]}


(import prelude/basic :unqualified)
(import prelude/bool :unqualified)
(import prelude/list :unqualified)
(import prelude/patterns :unqualified)

(def assert-equal
  "Compares `actual` with `expected` with `eq?`. If the values are not equal an
  `'assertion-error` is thrown. Otherwise `actual` is retuned."
  (fn [actual expected]
    (if (eq? actual expected)
        actual
        (throw 'assertion-error (string-append "failed: got " (show actual) " but expected " (show expected))))
))

;; Utils

(def try
  "Call `f` and catch any errors with `tag`. If no errors were thrown
  then return `[:ok r]` where `r` is the result of calling `f`. If an
  error was thrown return `[:error e]` where `e` is the second argument
  to `throw`."
  (fn [tag f]
    (def handle-error
      (fn [msg] [:error msg]))
    (catch tag [:ok (f)] handle-error)
  ))

(def foldl-with-index
  "Like `(fold f r xs)` but evaluates `(f acc x i)` where `i` is an
  additional index argument that starts with 0."
  (fn [f r xs]
    (head
      (foldl
        (fn [acc x]
          (match acc ['r 'i] [(f r x i) (+ i 1)]))
        [r 0]
        xs))
  ))

(def parse-doc-test-step
  "Parse a doc test step of the form `[ actual ==> expected ]` and
  returns a function that when called with an environments runs the
  step.

  Running a doc step means evluating `actual` in the given environment
  and comparing the result with `expected` using `assert-equal`."
  (fn [step]
    (def lhs (nth 0 step))
    (def marker (nth 1 step))
    (def rhs (nth 2 step))
    (if (eq? marker '==>)
        (fn [env]
          (def lhs-res (head (eval lhs env)))
          (assert-equal lhs-res rhs))
        (throw 'parse-test-step "Expected and actual not separate by ==>"))
  ))

(def extract-setup
  "Extracts the a setup step from the test steps. Returns a `[setup steps]` tuple."
  (fn [steps]
    (match steps
      (/cons [:setup 'setup] 'steps)
        [setup steps]
      'steps
        [:nothing steps])
  ))

(def print-test-result
  "Print a test result to stdout using the Test Anyhting Protocol (TAP)."
  (fn [name result i]
    (match result
      [:ok _]      (put-str! (string-append "ok " (show i) " - " name))
      [:error 'msg] (put-str! (string-append "not ok " (show i) " - " name)))))

(def run
  "Run the tests in `test-def` and print the result. `test-def` is a `{:env env
  :tests tests :name name}` dictionary where `env` is a radicle environment and
  `tests` is a list of quoted test cases with an optional `:setup` item.
  ```
  '(
    [:setup (do
      (def foo #t)
    )]
    [ foo ==> #t ]
    [ (not foo) ==> #f ]
  )
  ```
  "
  (fn [test-def index]
    (def test-env (lookup :env test-def))
    (def test-name (lookup :name test-def))
    (def test-contents (lookup :tests test-def))
    (def setup-and-steps (extract-setup (lookup :tests test-def)))
    (def setup (nth 0 setup-and-steps))
    (def steps (nth 1 setup-and-steps))
    (def step-runners (map parse-doc-test-step steps))
    (def test-env (nth 1 (eval setup test-env)))
    (def result
      (try 'any
        (fn []
          (map (fn [r] (r test-env)) step-runners)
          :nil)))
    (print-test-result test-name result index)
    (match result
      [:error _] #f
      [:ok _] #t)
))


(def run-all
  "Run all `tests` and print the results. Returns `#f` if at least one test fails and `#t` otherwise."
  (fn [tests]
    (put-str! (string-append "1.." (show (length tests))))
    (foldl-with-index
      (fn [ok t i] (and ok (run t (+ 1 i))))
      #t
      tests)
  ))
