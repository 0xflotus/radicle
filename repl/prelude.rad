(define should-be
  (lambda (name x y)
    (if (eq? x y)
        (print! (string-append "Test '" name "' succeeded"))
        (print! (string-append "Test '" name "' failed")))))

;; empty?
(define empty? (lambda (ls) (eq? ls (list))))
(should-be "empty" (empty? (list 2)) #f)

;; y-combinator
(define Y
  (lambda (h)
    ((lambda (x) (x x))
     (lambda (g)
       (h (lambda (arg) ((g g) arg)))))))
(define Y2
  (lambda (h)
    ((lambda (x) (x x))
     (lambda (g)
       (h (lambda (arg1 arg2) ((g g) arg1 arg2)))))))

((lambda ()
  (define fac (Y (lambda (f) (lambda (x) (if (< x 2) 1 (* x (f (- x 1))))))))
  (should-be "fac" (fac 10) 3628800)))

;; reverse
(define reverse (lambda (ls)
  (define go (Y2 (lambda (go)
    (lambda (acc new)
      (if (empty? new)
          acc
          (go (cons (car new) acc) (cdr new)))))))
  (go (list) ls)))

(should-be "reverse" (reverse (list 1 2 3)) (list 3 2 1))

;; range
(define range (Y2 (lambda (range) (lambda (from to)
  (if (eq? from to)
      (list to)
      (cons from (range (+ 1 from) to)))))))

(should-be "range" (range 1 5) (list 1 2 3 4 5))

;; filter
(define filter (Y2 (lambda (filter) (lambda (cond ls)
  (if (empty? ls)
      ls
  (if (cond (car ls))
      (cons (car ls) (filter cond (cdr ls)))
      (filter cond (cdr ls))))))))

(should-be "filter"
  (filter (lambda (x) (< x 10)) (list 3 10 11))
  (list 3))

;; modify-ref
(define modify-ref (lambda (ref fn)
  (write-ref ref (fn (deref ref)))))

;; modify-map
(define modify-map (lambda (key fn mp)
  (insert key (fn (lookup key mp)) mp)))

(should-be "modify-map"
  (modify-map 'a (lambda (x) (+ x 1)) (sorted-map a 5))
  (sorted-map a 6))

;; Account stuff. Should be moved elsewhere when we have an import mechanism

(define create-currency (lambda ()

  ;; The map of all accounts
  (define accounts (ref (sorted-map)))

  ;; Create an account with 10 coins.
  (define new-account (lambda (name)
    (modify-ref accounts (lambda (acc)
      (insert name 10 acc)))))

  ;; Get an account's balance
  (define account-balance (lambda (name)
    (lookup name (deref accounts))))

  ;; Transfer money
  (define transfer (lambda (from to amount)
    (define acc (deref accounts))
    (write-ref accounts (if (> amount (lookup from acc))
            (print! "not enough balance")
            (modify-map
              to
              (lambda (x) (+ x amount))
              (modify-map from (lambda (x) (- x amount)) acc))))))

  (define dispatch (lambda (m)
    (if (eq? m 'new-account) new-account
    (if (eq? m 'account-balance) account-balance
    (if (eq? m 'transfer) transfer
        (print! "error: currency- unknown message"))))))
  dispatch))

(define currency (create-currency))


(define new-eval (lambda (expr)
  (if (eq? (car expr) 'new-account)
      ((currency 'new-account) (car (cdr expr)))
  (if (eq? (car expr) 'account-balance)
      ((currency 'account-balance) (car (cdr expr)))
  (if (eq? (car expr) 'transfer)
      ((currency 'transfer) (car (cdr expr)) (car (cdr (cdr expr))) (car (cdr
                      (cdr (cdr expr)))))
  (print! "transaction must be new-account, transfer, or account-balance"))))))


;; The Repl

(define repl
  (sorted-map
     name "repl"
     ;; Parse errors are thrown here
     getter (lambda () (catch 'parse-error (get-line!) print!))))

;; Evaluation errors are thrown here
(catch 'any
    (subscribe-to! repl print!)
    (lambda (x) (print! x) (subscribe-to! repl print!)))
