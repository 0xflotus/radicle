{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
module Radicle.Tests where

import           Data.Data ((:~:)(Refl), Data, cast, eqT)
import           Data.Functor.Identity (runIdentity)
import           Data.Generics (everywhere)
import           Data.Semigroup ((<>))
import           Data.String.QQ (s)
import qualified Data.Text as T
import qualified Data.Text.IO as T
import           GHC.Exts (fromList, toList)
import           Test.Tasty
import           Test.Tasty.HUnit
import           Test.Tasty.QuickCheck (counterexample, testProperty)

import           Radicle.Internal.Arbitrary ()
import           Radicle.Internal.Core (toIdent)
import           Radicle.Internal.TestCapabilities
import           Radicle

import           Paths_radicle  -- generated by cabal via 'data-files'

test_eval :: [TestTree]
test_eval =
    [ testCase "Fails for undefined atoms" $
        [s|blah|] `failsWith` UnknownIdentifier (toIdent "blah")

    , testCase "Succeeds for defined atoms" $ do
        let prog = [s|
              (define rocky-clark "Steve Wozniak")
              rocky-clark
              |]
        prog `succeedsWith` String "Steve Wozniak"

    , testCase "'sorted-map' creates a SortedMap with given key/vals" $ do
        let prog = [s|(sorted-map why "not")|]
        prog `succeedsWith` SortedMap (fromList [(toIdent "why", String "not")])

    , testCase "'eval' evaluates the list" $ do
        let prog = [s|(eval (quote #t))|]
        prog `succeedsWith` Boolean True

    , testCase "lambdas work" $ do
        let prog = [s|((lambda (x) x) #t)|]
        prog `succeedsWith` Boolean True

    , testCase "lambda does not have access to future definitions (hyper static)" $ do
        let prog = [s|
              (define y "a")
              (define lam (lambda () y))
              (define y "b")
              (lam)
              |]
        prog `succeedsWith` String "a"

    , testCase "'if' works with three arguments and true cond" $ do
        let prog = [s|(if #t "a" "b")|]
        prog `succeedsWith` String "a"

    , testCase "'if' works with three arguments and false cond" $ do
        let prog = [s|(if #f "a" "b")|]
        prog `succeedsWith` String "b"

    , testCase "'if' is lazy" $ do
        let prog = [s|(if #t "a" (#t "non-sense"))|]
        prog `succeedsWith` String "a"

    , testCase "'string?' is true for strings" $ do
        let prog = [s|(string? "hi")|]
        prog `succeedsWith` Boolean True

    , testCase "'string?' is false for nonStrings" $ do
        let prog = [s|(string? #f)|]
        prog `succeedsWith` Boolean False

    , testCase "'string?' is false for nonStrings" $ do
        let prog = [s|(string? #f)|]
        prog `succeedsWith` Boolean False

    , testCase "'boolean?' is true for booleans" $ do
        let prog = [s|(boolean? #t)|]
        prog `succeedsWith` Boolean True

    , testCase "'boolean?' is true for non-booleans" $ do
        let prog = [s|(boolean? "hi")|]
        prog `succeedsWith` Boolean False

    , testCase "'define' fails when first arg is not an atom" $ do
        let prog = [s|(define "hi" "there")|]
        prog `failsWith` OtherError "define expects atom for first arg"

    , testCase "evaluation can be redefined" $ do
        let prog = [s|
            (define eval (lambda (x) #f))
            #t
            |]
        prog `succeedsWith` Boolean False
    ]
  where
    run src              = runIdentity $ runLang pureEnv
                                       $ interpretMany "(test)" src
    failsWith src err    = run src @?= Left err
    succeedsWith src val = run src @?= Right val

test_parser :: [TestTree]
test_parser =
    [ testCase "parses strings" $ do
        "\"hi\"" ==> String "hi"

    , testCase "parses booleans" $ do
        "#t" ==> Boolean True
        "#f" ==> Boolean False

    , testCase "parses primops" $ do
        "boolean?" ==> Primop (toIdent "boolean?")
        "base-eval" ==> Primop (toIdent "base-eval")

    , testCase "parses identifiers" $ do
        "++" ==> Atom (toIdent "++")
        "what?crazy!" ==> Atom (toIdent "what?crazy!")

    , testCase "parses identifiers that have a primop as prefix" $ do
        "evaluate" ==> Atom (toIdent "evaluate")

    , testCase "parses function application" $ do
        "(++)" ==> (Atom (toIdent "++") $$ [])
        "(++ \"merge\" \"d\")" ==> (Atom (toIdent "++") $$ [String "merge", String "d"])
    ]
  where
    x ==> y = parseTest x @?= Right y

test_binding :: [TestTree]
test_binding =
    [ testCase "handles shadowing correctly" $ do
        [s|(((lambda (x) (lambda (x) x)) "inner") "outer")|] ==> String "outer"
    ]
  where
    x ==> y = runIdentity (interpret "test" x pureEnv) @?= Right y


test_pretty :: [TestTree]
test_pretty =
    [ testProperty "pretty . parse == identity" $ \val ->
        let rendered = renderCompactPretty val
            actual = parseTest rendered
            original = removeEnv val
            info = case actual of
              Left e -> "parse error in: " <> T.unpack rendered <> "\n"
                      <> e
              Right v -> "pretty: " <> T.unpack rendered <> "\n"
                      <> "reparsed: " <> show v <> "\n"
                      <> "original: " <> show original <> "\n"
        in counterexample info $ actual == Right original
    ]

test_env :: [TestTree]
test_env =
    [ testProperty "fromList . toList == identity" $ \(env' :: Env) ->
        fromList (toList env') == env'
    ]

test_repl_primops :: [TestTree]
test_repl_primops =
    [ testProperty "get-line! returns the input line" $ \(v :: Value) ->
        let res = run [renderCompactPretty v] [s|(get-line!)|]
            expected = Right $ List [removeEnv v]
            info = "Expected: " <> show expected <> "\nGot: " <> show res
        in counterexample info $ res == expected

    , testCase "'deref-all' gives the value of a binding at call site" $ do
        let prog = [s|
                (define x #f)
                (define y (ref x))
                (define x #t)
                (deref-all y)
                |]
            res = run [] prog
        res @?= Right (Boolean True)

    , testProperty "deref-all . ref == id" $ \(i', v) -> do
        let derefed = Primop (toIdent "deref-all") $$ [Ref i']
            atom = Atom i'
            run' p = runTestWith (addBinding i' v pureEnv) [] (eval p)
        run' derefed == run' atom
    ]
    where
      run inp prog = fst $ runTestWith replBindings inp
                         $ interpretMany "(test)" prog

test_repl :: [TestTree]
test_repl =
    [ testCase "evaluates correctly" $ do
        let input = [ "((lambda (x) x) #t)" ]
            output = [ "'(#t)" ]
        (_, result) <- runInRepl input
        result @?= output

    , testCase "handles env modifications" $ do
        let input = [ "(define id (lambda (x) x))"
                    , "(id #t)"
                    ]
            output = [ "'('())"
                     , "'(#t)"
                     ]
        (_, result) <- runInRepl input
        result @?= output

    , testCase "handles 'eval' redefinition" $ do
        let input = [ "(define eval (lambda (x) #t))"
                    , "#f"
                    ]
            output = [ "'('())"
                     , "#t"
                     ]
        (_, result) <- runInRepl input
        result @?= output

    , testCase "(define eval (quote base-eval)) doesn't change things" $ do
        let input = [ "(define eval (quote base-eval))"
                    , "(define id (lambda (x) x))"
                    , "(id #t)"
                    ]
            output = [ "'('())"
                     , "'('())"
                     , "'(#t)"
                     ]
        (_, result) <- runInRepl input
        result @?= output
    ]
    where
      getCfg = getDataFileName "repl/config.rad" >>= T.readFile
      runInRepl inp = runTestWith replBindings inp
                    . interpretMany "(test)" <$> getCfg

-- * Utils

-- | Environments are neither printed nor parsed, but are generated by the
-- arbitrary instance.
removeEnv :: Value -> Value
removeEnv = everywhere go
  where
    go :: forall b. Data b => (b -> b)
    go x = case (cast x, eqT :: Maybe (b :~: Value)) of
        (Just (Lambda arg body _), Just Refl) -> Lambda arg body Nothing
        _                                     -> x
